import { Issue } from '../types';

// --- Type Declarations for Global Libraries ---
// These declarations provide TypeScript with the necessary type information for libraries
// loaded via <script> tags in index.html, preventing runtime errors.

// jsPDF and its autoTable plugin
declare global {
  namespace jspdf {
    interface jsPDF {
      autoTable: (options: any) => jsPDF;
      lastAutoTable: {
        finalY: number;
      };
      internal: any;
      addPage: (...args: any[]) => any;
      setPage: (...args: any[]) => any;
      setFontSize: (...args: any[]) => any;
      setTextColor: (...args: any[]) => any;
      text: (...args: any[]) => any;
      setFillColor: (...args: any[]) => any;
      rect: (...args: any[]) => any;
      setFont: (...args: any[]) => any;
      splitTextToSize: (...args: any[]) => string[];
      getTextWidth: (...args: any[]) => number;
      roundedRect: (...args: any[]) => any;
      setDrawColor: (...args: any[]) => any;
      line: (...args: any[]) => any;
      save: (...args: any[]) => any;
    }
  }
}

// PptxGenJS, accessed via the window object
declare class PptxGenJS {
  constructor();
  layout: string;
  defineSlideMaster(options: any): void;
  addSlide(options?: { masterName?: string }): any;
  writeFile(options: { fileName: string }): Promise<string>;
  shapes: any;
}
declare global {
  interface Window {
    jspdf: {
      jsPDF: new (options?: any) => jspdf.jsPDF;
    };
    PptxGenJS: (new () => PptxGenJS) | { default: new () => PptxGenJS };
  }
}


// --- Shared Constants and Helpers ---

/**
 * A helper to poll for a global library to be available on the window object.
 * This is crucial for handling race conditions where the export function is called
 * before the library's <script> tag has finished loading.
 * @param name The name of the library on the `window` object.
 * @param timeout The maximum time to wait in milliseconds.
 * @returns A promise that resolves with the library object.
 */
const waitForGlobal = <T>(name: string, timeout = 5000): Promise<T> => {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();
        const check = () => {
            const lib = (window as any)[name];
            if (lib) {
                return resolve(lib);
            }
            if (Date.now() - startTime > timeout) {
                return reject(new Error(`Library '${name}' failed to load within ${timeout}ms.`));
            }
            setTimeout(check, 100);
        };
        check();
    });
};

const BRAND_COLORS = {
  primary: '#1e3a8a',
  secondary: '#3b82f6',
  dark: '#1e293b',
  textDark: '#334155',
  textLight: '#64748b',
};

const SEVERITY_COLORS_HEX = {
  High: '#ef4444',
  Medium: '#f97316',
  Low: '#22c55e',
};

const groupIssuesByTable = (issues: Issue[]): Record<string, Issue[]> => {
  return issues.reduce((acc, issue) => {
    const tableName = issue.table_name || 'General Issues';
    if (!acc[tableName]) {
      acc[tableName] = [];
    }
    acc[tableName].push(issue);
    return acc;
  }, {} as Record<string, Issue[]>);
};


// --- PDF EXPORT (Reimagined & Stabilized) ---

export const generatePdfReport = async (issues: Issue[]): Promise<void> => {
  try {
    const jspdfLib = await waitForGlobal<any>('jspdf');
    if (!jspdfLib || typeof jspdfLib.jsPDF !== 'function') {
      throw new Error("jsPDF library is loaded, but the 'jsPDF' constructor is missing.");
    }
    const jsPDFConstructor = jspdfLib.jsPDF;

    const doc = new jsPDFConstructor({ orientation: 'p', unit: 'mm', format: 'a4' });
    const pageHeight = doc.internal.pageSize.getHeight();
    const pageWidth = doc.internal.pageSize.getWidth();
    let yPos = 0;

    const addHeaderAndFooter = () => {
      const pageCount = (doc as any).internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(10);
        doc.setTextColor(BRAND_COLORS.primary);
        doc.text('Data Quality Analysis Report', 15, 12);

        doc.setFontSize(8);
        doc.setTextColor(BRAND_COLORS.textLight);
        doc.text(`Page ${i} of ${pageCount}`, pageWidth - 25, pageHeight - 10);
        doc.text(`Generated: ${new Date().toLocaleDateString()}`, 15, pageHeight - 10);
      }
    };

    // --- Page 1: Title Page ---
    doc.setFillColor(BRAND_COLORS.primary);
    doc.rect(0, 0, pageWidth, pageHeight, 'F');
    doc.setFontSize(32);
    doc.setTextColor('#FFFFFF');
    doc.setFont('helvetica', 'bold');
    doc.text('Data Quality Analysis Report', pageWidth / 2, pageHeight / 2 - 20, { align: 'center' });
    doc.setFontSize(16);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated by Data Quality Bot`, pageWidth / 2, pageHeight / 2 - 10, { align: 'center' });


    // --- Page 2: Summary Page ---
    doc.addPage();
    yPos = 25;
    doc.setFontSize(22);
    doc.setTextColor(BRAND_COLORS.dark);
    doc.setFont('helvetica', 'bold');
    doc.text('Executive Summary', 15, yPos);
    yPos += 15;

    const severityCounts = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, { High: 0, Medium: 0, Low: 0 } as Record<Issue['severity'], number>);

    const autoTableOptions = {
      startY: yPos,
      head: [['Metric', 'Count']],
      body: [
        ['Total Issues Found', issues.length.toString()],
        ['High Severity Issues', severityCounts.High.toString()],
        ['Medium Severity Issues', severityCounts.Medium.toString()],
        ['Low Severity Issues', severityCounts.Low.toString()],
      ],
      theme: 'striped',
      headStyles: { fillColor: BRAND_COLORS.primary },
      styles: { fontSize: 11 },
      margin: { left: 15, right: 15 },
    };

    (doc as any).autoTable(autoTableOptions);

    yPos = doc.lastAutoTable.finalY + 20;

    // --- Detailed Findings Pages ---
    const issuesByTable = groupIssuesByTable(issues);

    Object.keys(issuesByTable).forEach(tableName => {
      doc.addPage();
      yPos = 25;

      doc.setFontSize(20);
      doc.setTextColor(BRAND_COLORS.primary);
      doc.setFont('helvetica', 'bold');
      doc.text(`Table: ${tableName}`, 15, yPos);
      yPos += 12;

      issuesByTable[tableName].forEach(issue => {
        const descriptionLines = doc.splitTextToSize(issue.description, pageWidth - 45);
        const recommendationLines = doc.splitTextToSize(issue.recommendation, pageWidth - 45);
        const estimatedHeight = 20 + (descriptionLines.length * 5) + (recommendationLines.length * 5);

        if (yPos + estimatedHeight > pageHeight - 25) {
          doc.addPage();
          yPos = 25;
        }

        doc.setFontSize(14);
        doc.setTextColor(BRAND_COLORS.dark);
        doc.setFont('helvetica', 'bold');
        doc.text(issue.type, 18, yPos);

        const severityColor = SEVERITY_COLORS_HEX[issue.severity];
        doc.setFillColor(severityColor);
        const severityText = issue.severity.toUpperCase();
        const textWidth = doc.getTextWidth(severityText) + 10;
        doc.roundedRect(pageWidth - 15 - textWidth, yPos - 6, textWidth, 8, 3, 3, 'F');
        doc.setFontSize(10);
        doc.setTextColor('#ffffff');
        doc.setFont('helvetica', 'bold');
        doc.text(severityText, pageWidth - 15 - (textWidth / 2), yPos - 1, { align: 'center' });

        yPos += 10;

        const addDetailText = (label: string, valueLines: string[]) => {
          doc.setFontSize(11);
          doc.setTextColor(BRAND_COLORS.dark);
          doc.setFont('helvetica', 'bold');
          doc.text(label, 20, yPos);
          doc.setFont('helvetica', 'normal');
          doc.setTextColor(BRAND_COLORS.textDark);
          doc.text(valueLines, 58, yPos);
          yPos += (valueLines.length * 5) + 3;
        };

        addDetailText('Description:', descriptionLines);
        addDetailText('Possible Cause:', doc.splitTextToSize(issue.possible_cause, pageWidth - 45));
        addDetailText('Recommendation:', recommendationLines);
        yPos += 5;
        doc.setDrawColor('#e5e7eb');
        doc.line(15, yPos, pageWidth - 15, yPos);
        yPos += 8;
      });
    });

    addHeaderAndFooter();
    doc.save('Data-Quality-Report.pdf');
  } catch(error) {
    console.error("Failed to generate PDF report:", error);
    alert("Could not generate PDF report. The required library might be missing or failed to load. Please check your network connection and try again.");
  }
};


// --- POWERPOINT EXPORT (Reimagined & Stabilized) ---

export const generatePptxReport = async (issues: Issue[]): Promise<void> => {
  try {
    const PptxGenJSConstructor = await waitForGlobal<any>('PptxGenJS');

    let PptxGenJS_;
    if (typeof PptxGenJSConstructor === 'function') {
      // Case 1: The global is the constructor itself (standard for this CDN script)
      PptxGenJS_ = PptxGenJSConstructor;
    } else if (PptxGenJSConstructor && typeof PptxGenJSConstructor.default === 'function') {
      // Case 2: The global is a module object with a 'default' export
      PptxGenJS_ = PptxGenJSConstructor.default;
    } else {
      // If neither, the library is not loaded correctly.
      console.error("Unrecognized PptxGenJS library format:", PptxGenJSConstructor);
      throw new Error("PptxGenJS library is loaded but is not in a recognized format.");
    }

    const pptx = new PptxGenJS_();
    pptx.layout = 'LAYOUT_WIDE';

    // --- Define Master Slide ---
    pptx.defineSlideMaster({
      title: 'MASTER_SLIDE',
      background: { color: 'F1F5F9' },
      objects: [
        { rect: { x: 0, y: 0, w: '100%', h: 0.5, fill: { color: BRAND_COLORS.primary } } },
        { text: { text: 'Data Quality Analysis Report', options: { x: 0.5, y: 0.1, w: '90%', fontFace: 'Arial', fontSize: 14, color: 'FFFFFF' } } },
      ],
      slideNumber: { x: 0.5, y: '95%', fontFace: 'Arial', fontSize: 10, color: BRAND_COLORS.primary },
    });

    const slideTitleStyle = { x: 0.5, y: 0.6, w: '90%', h: 0.75, fontSize: 32, fontFace: 'Arial', bold: true, color: BRAND_COLORS.primary };

    // --- Slide 1: Title Slide ---
    const titleSlide = pptx.addSlide();
    titleSlide.background = { color: 'FFFFFF' };
    titleSlide.addText('Data Quality Analysis Report', { x: 0, y: 2.5, w: '100%', h: 1, fontSize: 44, bold: true, color: BRAND_COLORS.primary, align: 'center' });
    titleSlide.addText(`Presented by Data Quality Bot`, { x: 0, y: 3.5, w: '100%', h: 0.5, fontSize: 20, color: BRAND_COLORS.secondary, align: 'center' });

    // --- Slide 2: Summary Slide ---
    const summarySlide = pptx.addSlide({ masterName: 'MASTER_SLIDE' });
    summarySlide.addText('Executive Summary', slideTitleStyle);

    const severityCounts = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, { High: 0, Medium: 0, Low: 0 } as Record<Issue['severity'], number>);

    const summaryTableRows = [
      [{ text: 'Metric', options: { bold: true, fill: BRAND_COLORS.primary, color: 'FFFFFF', align: 'center' } }, { text: 'Count', options: { bold: true, fill: BRAND_COLORS.primary, color: 'FFFFFF', align: 'center' } }],
      ['Total Issues Found', { text: issues.length, options: { bold: true, align: 'center' } }],
      ['High Severity Issues', { text: severityCounts.High, options: { color: SEVERITY_COLORS_HEX.High, bold: true, align: 'center' } }],
      ['Medium Severity Issues', { text: severityCounts.Medium, options: { color: SEVERITY_COLORS_HEX.Medium, bold: true, align: 'center' } }],
      ['Low Severity Issues', { text: severityCounts.Low, options: { color: SEVERITY_COLORS_HEX.Low, bold: true, align: 'center' } }],
    ];
    summarySlide.addTable(summaryTableRows, { x: 1, y: 1.8, w: 8, rowH: 0.5, colW: [4, 4], border: { type: 'solid', pt: 1, color: 'FFFFFF' }, autoPage: false });

    // --- Issue Slides ---
    const issuesByTable = groupIssuesByTable(issues);

    Object.keys(issuesByTable).forEach(tableName => {
      const dividerSlide = pptx.addSlide({ masterName: 'MASTER_SLIDE' });
      dividerSlide.addText(`Table: ${tableName}`, { x: 0, y: 0, w: '100%', h: '100%', align: 'center', valign: 'middle', fontSize: 40, bold: true, color: BRAND_COLORS.secondary });

      issuesByTable[tableName].forEach(issue => {
        const issueSlide = pptx.addSlide({ masterName: 'MASTER_SLIDE' });
        issueSlide.addText(issue.type, { ...slideTitleStyle, fontSize: 24, h: 0.5 });

        const severityColor = SEVERITY_COLORS_HEX[issue.severity];
        issueSlide.addShape((pptx.shapes as any).RECTANGLE, { x: 11.5, y: 0.6, w: 1.5, h: 0.5, fill: { color: severityColor } });
        issueSlide.addText(issue.severity, { x: 11.5, y: 0.6, w: 1.5, h: 0.5, align: 'center', color: 'FFFFFF', bold: true, fontSize: 16 });

        const addContentBox = (title: string, text: string, y: number) => {
          issueSlide.addText(title, { x: 0.5, y: y, w: 4, h: 0.4, fontFace: 'Arial', bold: true, color: BRAND_COLORS.primary, fontSize: 16 });
          issueSlide.addText(text, { x: 0.5, y: y + 0.4, w: '90%', h: 1.2, fontFace: 'Arial', color: BRAND_COLORS.textDark, fontSize: 14 });
        };

        addContentBox('Description', issue.description, 1.5);
        addContentBox('Potential Impact', issue.impact, 3.0);
        addContentBox('Recommendation', issue.recommendation, 4.5);
      });
    });

    pptx.writeFile({ fileName: 'Data-Quality-Report.pptx' });
  } catch (error) {
    console.error("Failed to generate PowerPoint report:", error);
    alert("Could not generate PowerPoint report. The 'PptxGenJS' library failed to load or initialize correctly. Please check your network connection and try again.");
  }
};