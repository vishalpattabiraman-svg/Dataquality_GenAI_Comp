import { Issue } from '../types';

// --- Type Declarations for Global Libraries ---
// These declarations provide TypeScript with the necessary type information for libraries
// loaded via <script> tags in index.html, preventing runtime errors.

// jsPDF and its autoTable plugin
declare global {
  namespace jspdf {
    interface jsPDF {
      autoTable: (options: any) => jsPDF;
      lastAutoTable: {
        finalY: number;
      };
      internal: any;
      addPage: (...args: any[]) => any;
      setPage: (...args: any[]) => any;
      setFontSize: (...args: any[]) => any;
      setTextColor: (...args: any[]) => any;
      text: (...args: any[]) => any;
      setFillColor: (...args: any[]) => any;
      rect: (...args: any[]) => any;
      setFont: (...args: any[]) => any;
      splitTextToSize: (...args: any[]) => string[];
      getTextWidth: (...args: any[]) => number;
      roundedRect: (...args: any[]) => any;
      setDrawColor: (...args: any[]) => any;
      line: (...args: any[]) => any;
      save: (...args: any[]) => any;
    }
  }
}

// PptxGenJS is now imported dynamically, so no global declaration is needed.
declare global {
  interface Window {
    jspdf: {
      jsPDF: new (options?: any) => jspdf.jsPDF;
    };
  }
}


// --- Shared Constants and Helpers ---

/**
 * A helper to poll for a global library to be available on the window object.
 * This is crucial for handling race conditions where the export function is called
 * before the library's <script> tag has finished loading.
 * @param name The name of the library on the `window` object.
 * @param timeout The maximum time to wait in milliseconds.
 * @returns A promise that resolves with the library object.
 */
const waitForGlobal = <T>(name: string, timeout = 20000): Promise<T> => {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();
        const check = () => {
            const lib = (window as any)[name];
            if (lib) {
                return resolve(lib);
            }
            if (Date.now() - startTime > timeout) {
                return reject(new Error(`Library '${name}' failed to load within ${timeout}ms.`));
            }
            setTimeout(check, 100);
        };
        check();
    });
};

const BRAND_COLORS = {
  primary: '#334155',    // slate-700
  secondary: '#0ea5e9',   // sky-500
  dark: '#0f172a',       // slate-900
  textDark: '#334155',   // slate-700
  textLight: '#64748b',  // slate-500
};

const SEVERITY_COLORS_HEX = {
  High: '#e11d48',    // rose-600
  Medium: '#f59e0b',  // amber-500
  Low: '#10b981',     // emerald-500
};

const groupIssuesByTable = (issues: Issue[]): Record<string, Issue[]> => {
  return issues.reduce((acc, issue) => {
    const tableName = issue.table_name || 'General Issues';
    if (!acc[tableName]) {
      acc[tableName] = [];
    }
    acc[tableName].push(issue);
    return acc;
  }, {} as Record<string, Issue[]>);
};


// --- PDF EXPORT (Reimagined & Stabilized) ---

export const generatePdfReport = async (issues: Issue[]): Promise<void> => {
  try {
    const jspdfLib = await waitForGlobal<any>('jspdf');
    if (!jspdfLib || typeof jspdfLib.jsPDF !== 'function') {
      throw new Error("jsPDF library is loaded, but the 'jsPDF' constructor is missing.");
    }
    const jsPDFConstructor = jspdfLib.jsPDF;

    const doc = new jsPDFConstructor({ orientation: 'p', unit: 'mm', format: 'a4' });
    const pageHeight = doc.internal.pageSize.getHeight();
    const pageWidth = doc.internal.pageSize.getWidth();
    const leftMargin = 15;
    const rightMargin = 15;
    const effectiveWidth = pageWidth - leftMargin - rightMargin;

    const addHeaderAndFooter = () => {
      const pageCount = (doc as any).internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(10);
        doc.setTextColor(BRAND_COLORS.primary);
        doc.text('Data Quality Analysis Report', 15, 12);

        doc.setFontSize(8);
        doc.setTextColor(BRAND_COLORS.textLight);
        doc.text(`Page ${i} of ${pageCount}`, pageWidth - 25, pageHeight - 10);
        doc.text(`Generated: ${new Date().toLocaleDateString()}`, 15, pageHeight - 10);
      }
    };

    // --- Page 1: Title Page ---
    doc.setFillColor(BRAND_COLORS.primary);
    doc.rect(0, 0, pageWidth, pageHeight, 'F');
    doc.setFontSize(32);
    doc.setTextColor('#FFFFFF');
    doc.setFont('helvetica', 'bold');
    doc.text('Data Quality Analysis Report', pageWidth / 2, pageHeight / 2 - 20, { align: 'center' });
    doc.setFontSize(16);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated by Data Quality Bot`, pageWidth / 2, pageHeight / 2 - 10, { align: 'center' });


    // --- Page 2: Summary Page ---
    doc.addPage();
    let yPos = 25;
    doc.setFontSize(22);
    doc.setTextColor(BRAND_COLORS.dark);
    doc.setFont('helvetica', 'bold');
    doc.text('Executive Summary', 15, yPos);
    yPos += 15;

    const severityCounts = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, { High: 0, Medium: 0, Low: 0 } as Record<Issue['severity'], number>);

    const autoTableOptions = {
      startY: yPos,
      head: [['Metric', 'Count']],
      body: [
        ['Total Issues Found', issues.length.toString()],
        ['High Severity Issues', severityCounts.High.toString()],
        ['Medium Severity Issues', severityCounts.Medium.toString()],
        ['Low Severity Issues', severityCounts.Low.toString()],
      ],
      theme: 'striped',
      headStyles: { fillColor: BRAND_COLORS.primary },
      styles: { fontSize: 11 },
      margin: { left: 15, right: 15 },
    };

    (doc as any).autoTable(autoTableOptions);

    // --- Page 3: Table of Contents Placeholder ---
    doc.addPage();
    const tocPage = doc.internal.getCurrentPageInfo().pageNumber;
    const tocEntries: { level: 1 | 2; title: string; page: number }[] = [];

    // --- Detailed Findings Pages ---
    const issuesByTable = groupIssuesByTable(issues);

    Object.keys(issuesByTable).forEach(tableName => {
      doc.addPage();
      const tableStartPage = doc.internal.getCurrentPageInfo().pageNumber;
      tocEntries.push({ level: 1, title: tableName, page: tableStartPage });

      yPos = 25;

      const drawTableHeader = (isContinued = false) => {
        const title = isContinued ? `Table: ${tableName} (continued)` : `Table: ${tableName}`;
        
        doc.setFontSize(20);
        doc.setTextColor(BRAND_COLORS.primary);
        doc.setFont('helvetica', 'bold');
        const titleLines = doc.splitTextToSize(title, effectiveWidth);
        doc.text(titleLines, leftMargin, yPos);
        const titleHeight = titleLines.length * 8; 
        yPos += titleHeight + 4;
      };

      drawTableHeader();

      issuesByTable[tableName].forEach(issue => {
        const contentStartX = 58;
        const contentWidth = pageWidth - contentStartX - rightMargin;
        
        const descriptionLines = doc.splitTextToSize(issue.description, contentWidth);
        const causeLines = doc.splitTextToSize(issue.possible_cause, contentWidth);
        const recommendationLines = doc.splitTextToSize(issue.recommendation, contentWidth);
        
        const lineHeight = 5;
        const sectionSpacing = 3;
        const headerHeight = 10;
        const footerHeight = 13;

        const calcSectionHeight = (lines: string[]) => (lines.length * lineHeight) + sectionSpacing;
        const requiredHeight = headerHeight + calcSectionHeight(descriptionLines) + calcSectionHeight(causeLines) + calcSectionHeight(recommendationLines) + footerHeight;

        if (yPos + requiredHeight > pageHeight - 20) {
          doc.addPage();
          yPos = 25;
          drawTableHeader(true);
        }

        const issuePage = doc.internal.getCurrentPageInfo().pageNumber;
        tocEntries.push({ level: 2, title: issue.type, page: issuePage });

        doc.setFontSize(14);
        doc.setTextColor(BRAND_COLORS.dark);
        doc.setFont('helvetica', 'bold');
        doc.text(issue.type, 18, yPos);

        const severityColor = SEVERITY_COLORS_HEX[issue.severity];
        doc.setFillColor(severityColor);
        const severityText = issue.severity.toUpperCase();
        const textWidth = doc.getTextWidth(severityText) + 10;
        doc.roundedRect(pageWidth - 15 - textWidth, yPos - 6, textWidth, 8, 3, 3, 'F');
        doc.setFontSize(10);
        doc.setTextColor('#ffffff');
        doc.setFont('helvetica', 'bold');
        doc.text(severityText, pageWidth - 15 - (textWidth / 2), yPos - 1, { align: 'center' });

        yPos += headerHeight;

        const addDetailText = (label: string, valueLines: string[]) => {
          doc.setFontSize(11);
          doc.setTextColor(BRAND_COLORS.dark);
          doc.setFont('helvetica', 'bold');
          doc.text(label, 20, yPos);
          doc.setFont('helvetica', 'normal');
          doc.setTextColor(BRAND_COLORS.textDark);
          doc.text(valueLines, contentStartX, yPos);
          yPos += calcSectionHeight(valueLines);
        };

        addDetailText('Description:', descriptionLines);
        addDetailText('Possible Cause:', causeLines);
        addDetailText('Recommendation:', recommendationLines);
        
        yPos += 5;
        doc.setDrawColor('#e5e7eb');
        doc.line(15, yPos, pageWidth - 15, yPos);
        yPos += 8;
      });
    });

    // --- Render Table of Contents ---
    doc.setPage(tocPage);
    let tocYPos = 25;
    doc.setFontSize(22);
    doc.setTextColor(BRAND_COLORS.dark);
    doc.setFont('helvetica', 'bold');
    doc.text('Table of Contents', 15, tocYPos);
    tocYPos += 15;

    doc.setFont('helvetica', 'normal');
    const bottomMargin = 20;

    tocEntries.forEach(entry => {
        if (tocYPos > pageHeight - bottomMargin) return; // Simple overflow protection

        const title = entry.title;
        const pageNumStr = entry.page.toString();
        const indent = entry.level === 1 ? 0 : 5;
        const xPos = leftMargin + indent;

        doc.setFontSize(entry.level === 1 ? 12 : 10);
        doc.setFont('helvetica', entry.level === 1 ? 'bold' : 'normal');
        doc.setTextColor(BRAND_COLORS.dark);

        const maxTitleWidth = effectiveWidth - indent - 20; 
        const truncatedTitle = doc.splitTextToSize(title, maxTitleWidth)[0];

        // Add clickable link to the page
        doc.textWithLink(truncatedTitle, xPos, tocYPos, { pageNumber: entry.page });

        const titleWidth = doc.getTextWidth(truncatedTitle);
        const dotWidth = doc.getTextWidth('.');
        const pageNumWidth = doc.getTextWidth(pageNumStr);
        const spaceForDots = effectiveWidth - indent - titleWidth - pageNumWidth;

        if (spaceForDots > 0) {
            const numDots = Math.floor(spaceForDots / dotWidth);
            const dots = '.'.repeat(numDots);
            doc.setTextColor(BRAND_COLORS.textLight);
            doc.text(dots, xPos + titleWidth, tocYPos);
        }

        doc.setTextColor(BRAND_COLORS.dark);
        doc.textWithLink(pageNumStr, pageWidth - rightMargin, tocYPos, { pageNumber: entry.page, align: 'right' });

        tocYPos += entry.level === 1 ? 8 : 6;
    });

    addHeaderAndFooter();
    doc.save('Data-Quality-Report.pdf');
  } catch(error) {
    console.error("Failed to generate PDF report:", error);
    alert("Could not generate PDF report. The required library might be missing or failed to load. Please check your network connection and try again.");
  }
};


// --- POWERPOINT EXPORT (Reimagined & Stabilized with Dynamic Import) ---

export const generatePptxReport = async (issues: Issue[]): Promise<void> => {
  try {
    // Dynamically import the library from a reliable ESM CDN.
    // This is far more robust than waiting for a global script to load.
    const PptxGenJSModule = await import('https://esm.sh/pptxgenjs@3.12.0');
    const PptxGenJS = PptxGenJSModule.default;

    if (!PptxGenJS) {
      throw new Error("PptxGenJS library could not be initialized from the imported module.");
    }

    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_WIDE';

    // --- Define Master Slide ---
    pptx.defineSlideMaster({
      title: 'MASTER_SLIDE',
      background: { color: 'F1F5F9' },
      objects: [
        { rect: { x: 0, y: 0, w: '100%', h: 0.5, fill: { color: BRAND_COLORS.primary.substring(1) } } },
        { text: { text: 'Data Quality Analysis Report', options: { x: 0.5, y: 0.1, w: '90%', fontFace: 'Arial', fontSize: 14, color: 'FFFFFF' } } },
      ],
      slideNumber: { x: 0.5, y: '95%', fontFace: 'Arial', fontSize: 10, color: BRAND_COLORS.primary.substring(1) },
    });

    const slideTitleStyle = { x: 0.5, y: 0.6, w: '90%', h: 0.75, fontSize: 32, fontFace: 'Arial', bold: true, color: BRAND_COLORS.primary.substring(1) };

    // --- Slide 1: Title Slide ---
    const titleSlide = pptx.addSlide();
    titleSlide.background = { color: 'FFFFFF' };
    titleSlide.addText('Data Quality Analysis Report', { x: 0, y: 2.5, w: '100%', h: 1, fontSize: 44, bold: true, color: BRAND_COLORS.primary.substring(1), align: 'center' });
    titleSlide.addText(`Presented by Data Quality Bot`, { x: 0, y: 3.5, w: '100%', h: 0.5, fontSize: 20, color: BRAND_COLORS.secondary.substring(1), align: 'center' });

    // --- Slide 2: Summary Slide ---
    const summarySlide = pptx.addSlide({ masterName: 'MASTER_SLIDE' });
    summarySlide.addText('Executive Summary', slideTitleStyle);

    const severityCounts = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, { High: 0, Medium: 0, Low: 0 } as Record<Issue['severity'], number>);

    const summaryTableRows = [
      [{ text: 'Metric', options: { bold: true, fill: { color: BRAND_COLORS.primary.substring(1) }, color: 'FFFFFF', align: 'center' } }, { text: 'Count', options: { bold: true, fill: { color: BRAND_COLORS.primary.substring(1) }, color: 'FFFFFF', align: 'center' } }],
      ['Total Issues Found', { text: issues.length, options: { bold: true, align: 'center' } }],
      ['High Severity Issues', { text: severityCounts.High, options: { color: SEVERITY_COLORS_HEX.High.substring(1), bold: true, align: 'center' } }],
      ['Medium Severity Issues', { text: severityCounts.Medium, options: { color: SEVERITY_COLORS_HEX.Medium.substring(1), bold: true, align: 'center' } }],
      ['Low Severity Issues', { text: severityCounts.Low, options: { color: SEVERITY_COLORS_HEX.Low.substring(1), bold: true, align: 'center' } }],
    ];
    summarySlide.addTable(summaryTableRows, { x: 1, y: 1.8, w: 8, rowH: 0.5, colW: [4, 4], border: { type: 'solid', pt: 1, color: 'FFFFFF' }, autoPage: false });

    // --- Issue Slides ---
    const issuesByTable = groupIssuesByTable(issues);

    Object.keys(issuesByTable).forEach(tableName => {
      const dividerSlide = pptx.addSlide({ masterName: 'MASTER_SLIDE' });
      dividerSlide.addText(`Table: ${tableName}`, { x: 0, y: 0, w: '100%', h: '100%', align: 'center', valign: 'middle', fontSize: 40, bold: true, color: BRAND_COLORS.secondary.substring(1) });

      issuesByTable[tableName].forEach(issue => {
        const issueSlide = pptx.addSlide({ masterName: 'MASTER_SLIDE' });
        issueSlide.addText(issue.type, { ...slideTitleStyle, fontSize: 24, h: 0.5 });

        const severityColor = SEVERITY_COLORS_HEX[issue.severity].substring(1);
        issueSlide.addShape((pptx.shapes as any).RECTANGLE, { x: 11.5, y: 0.6, w: 1.5, h: 0.5, fill: { color: severityColor } });
        issueSlide.addText(issue.severity, { x: 11.5, y: 0.6, w: 1.5, h: 0.5, align: 'center', color: 'FFFFFF', bold: true, fontSize: 16 });

        const addContentBox = (title: string, text: string, y: number) => {
          issueSlide.addText(title, { x: 0.5, y: y, w: 4, h: 0.4, fontFace: 'Arial', bold: true, color: BRAND_COLORS.primary.substring(1), fontSize: 16 });
          issueSlide.addText(text, { x: 0.5, y: y + 0.4, w: '90%', h: 1.2, fontFace: 'Arial', color: BRAND_COLORS.textDark.substring(1), fontSize: 14, fit: 'shrink' });
        };

        addContentBox('Description', issue.description, 1.5);
        addContentBox('Potential Impact', issue.impact, 3.0);
        addContentBox('Recommendation', issue.recommendation, 4.5);
      });
    });

    pptx.writeFile({ fileName: 'Data-Quality-Report.pptx' });
  } catch (error) {
    console.error("Failed to generate PowerPoint report:", error);
    alert("Could not generate PowerPoint report. The required library failed to load, which may be due to a network issue. Please check your connection and try again.");
  }
};